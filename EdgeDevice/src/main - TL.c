#include <zephyr.h>
#include <sys/printk.h>

#include <stdio.h>
#include <stdlib.h>
#include <timing/timing.h>
#include <time.h>

#include "../c25519/src/c25519.h"
#include "../c25519/src/ed25519.h"
#include "../c25519/src/sha256.h"

 // Key Manager Functions
uint8_t SK_S[ED25519_EXPONENT_SIZE];
uint8_t pks_x[F25519_SIZE];
uint8_t pks_y[F25519_SIZE];
struct ed25519_pt PK_S;


//Performance Parameters (Time Measurements)
timing_t stA, etA;
uint64_t tA_cycles;
uint64_t tA_ns;
const char *tmstmp = "255";


typedef struct {
    char ID[5];
    uint8_t k_i[F25519_SIZE];                   //self-generated secret key
    uint8_t tk_i_x[F25519_SIZE];                //self-generated transfer key based on k_i
    uint8_t tk_i_y[F25519_SIZE];
    uint8_t rk_i_x[F25519_SIZE];                //re-key key generated by KM based on received tk_i
    uint8_t rk_i_y[F25519_SIZE];
    uint8_t rt_i_x[F25519_SIZE];                //part of the first level tag
    uint8_t rt_i_y[F25519_SIZE];
    uint8_t c_i[F25519_SIZE];
    uint8_t s_i[F25519_SIZE];
} Rusers;

Rusers RU[5000];
int cnt = 500;
// =============================================================================================================================================

static void displayHex(const uint8_t *hex){
    int i;
    printf(" ");
    for (i = 0; i < F25519_SIZE; i++){
        printf("%02x", hex[i]);
    }
    printf("\n");
}

static void print_point(const uint8_t *x, const uint8_t *y)
{
    int i;

    printf("  ");
    for (i = 0; i < F25519_SIZE; i++)
        printf("%02x", x[i]);
    printf(", ");
    for (i = 0; i < F25519_SIZE; i++)
        printf("%02x", y[i]);
    printf("\n");
}

static void GenKey(uint8_t *key){
    //timing_t start_time, end_time;
    //uint64_t total_cycles;
    //uint64_t total_ns;

    //timing_init();
    //timing_start();
    //start_time = timing_counter_get();
    for (int i = 0; i < ED25519_EXPONENT_SIZE; i++){
        key[i] = rand();
    }
    c25519_prepare(key);
    //end_time = timing_counter_get();

    //total_cycles = timing_cycles_get(&start_time, &end_time);
    //total_ns = timing_cycles_to_ns(total_cycles);
    //timing_stop();

    displayHex(key);

}


static void performExp(struct ed25519_pt *out, struct ed25519_pt *base, uint8_t * pwr, uint8_t *ax, uint8_t *ay){
    ed25519_smult(out, base, pwr);
    ed25519_unproject(ax, ay, out);

    print_point(ax, ay);
}


static void Hash256(uint8_t *digest, const char *msg, struct tc_sha256_state_struct stx){
    (void)tc_sha256_init(&stx);
    tc_sha256_update(&stx, (const uint8_t *)msg, strlen(msg));
    (void)tc_sha256_final(digest, &stx);
}

static void ProcessFunction(Rusers *U){         //Process Function run by each user
    for (int i = 0; i<cnt; i++)
    {
        snprintf(U[i].ID, 5, "%d", i);
        uint8_t x_i[F25519_SIZE];
        uint8_t k_i[ED25519_EXPONENT_SIZE], tk_i[ED25519_EXPONENT_SIZE];
        uint8_t tki_x[F25519_SIZE], tki_y[F25519_SIZE];
        struct ed25519_pt TK_I;

        //Hash Parameters
        uint8_t HM[F25519_SIZE];
        struct tc_sha256_state_struct stx;

        //Process Parameters
        uint8_t c_i[F25519_SIZE], r_i_x[F25519_SIZE], r_i_y[F25519_SIZE], sum_hash[F25519_SIZE];
        uint8_t e_i[ED25519_EXPONENT_SIZE];
        uint8_t s_i[F25519_SIZE];
        uint8_t HM_SUM[F25519_SIZE];
        struct ed25519_pt RK_I;

        //random x_i
        for (int j = 0; j < F25519_SIZE; j++){
            x_i[j] = rand();
        }
        printf("x_i = ");
        displayHex(x_i);
        printf("\n");

        printf("K_I:");
        GenKey(k_i);                                               // k_i
        f25519_copy(U[i].k_i, k_i);
        printf("\n");

        f25519_inv(tk_i, k_i);                                     // 1/k_i
        
        printf("Transfer Key for A:");
        performExp(&TK_I, &ed25519_base, tk_i, tki_x, tki_y);       // rk_A = h^(1/k_i)
        printf("\n");
        f25519_copy(U[i].tk_i_x, tki_x);
        f25519_copy(U[i].tk_i_y, tki_y);

        //Multiply key and message (k_i.x_i_t) + H(t)
        Hash256(HM, tmstmp, stx);                                   // H(t)
        printf("Hashed Timestamp (255):");
        displayHex(HM);
        printf("\n");

        f25519_mul(c_i, x_i, k_i);                                 // k_i * x_i_t
        f25519_add(c_i, c_i, HM);                                   // c_i = k_i * x_i_t + H(t)
        printf("First-Level Cipher:");
        displayHex(c_i);
        f25519_copy(U[i].c_i, c_i);
        printf("\n");

        printf("E_I: ");
        GenKey(e_i);
        printf("\n");

        printf("Process Key:A :");
        performExp(&RK_I, &ed25519_base, e_i, r_i_x, r_i_y);        // r_i_t = h^(e_i_t)
        printf("\n");
        f25519_copy(U[i].rt_i_x, r_i_x);
        f25519_copy(U[i].rt_i_y, r_i_y);

        f25519_add(e_i, e_i, x_i);                                  // e_i = x_i + e_i_t
        
        //H(t||r_i_t) = Using addition to simplify the implementation
        f25519_add(sum_hash, r_i_x, r_i_y);
        f25519_add(sum_hash, sum_hash, (uint8_t *)tmstmp);
        Hash256(HM_SUM, (char *)sum_hash, stx);

        f25519_add(s_i, e_i, HM_SUM);                              // (x_i + e_i_t + H(t||r_i_t))
        f25519_mul(s_i, k_i, s_i);                                 // k_i(x_i + e_i_t + H(t||r_i_t))
        f25519_copy(U[i].s_i, s_i);

        printf("First-Level Tag (%d):", i);
        displayHex(s_i);
        printf("\n");
        printf("==================================================================================================\n\n");
    }    
}

static void reKey(Rusers *U, uint8_t *key){
    for (int i = 0; i < cnt; i++){
        //Rekey Parameters
        uint8_t rki_x[F25519_SIZE], rki_y[F25519_SIZE];
        struct ed25519_pt RKI_S;
        struct ed25519_pt TK_I;

        ed25519_project(&TK_I, U[i].tk_i_x, U[i].tk_i_y);


        //KM ReKey Process
        printf("ReKey for User %s:KM:", U[i].ID);
        performExp(&RKI_S, &TK_I, key, rki_x, rki_y);              // rk_i_s = (h^(1/k_i))^k
        printf("\n");

        f25519_copy(U[i].rk_i_x, rki_x);
        f25519_copy(U[i].rk_i_y, rki_y);
    }
}

static void reProcess(Rusers *U){
    for (int i = 0; i < cnt; i++){
        //reProcess Parameters
        struct ed25519_pt cprime_i; 
        struct ed25519_pt sprime_i;
        struct ed25519_pt RKI_S;

        uint8_t c_sub[F25519_SIZE];
        uint8_t cprime_x[F25519_SIZE], cprime_y[F25519_SIZE];
        uint8_t sprime_x[F25519_SIZE], sprime_y[F25519_SIZE];

        //Hash Parameters
        uint8_t HM[F25519_SIZE];
        struct tc_sha256_state_struct stx;

        Hash256(HM, tmstmp, stx);                   // H(t)
        ed25519_project(&RKI_S, U[i].rk_i_x, U[i].rk_i_y);

        f25519_sub(c_sub, U[i].c_i, HM);            // c_i_t - H(t)

        printf("ReProcess for User %s:(C'):", U[i].ID);
        performExp(&cprime_i, &RKI_S, c_sub, cprime_x, cprime_y);
        printf("\n");

        printf("ReProcess for User %s:(S'):", U[i].ID);
        performExp(&sprime_i, &RKI_S, U[i].s_i, sprime_x, sprime_y);
        printf("\n");

    }
}


void main(void)
{
    //timing_t st, et;
    //uint64_t total_cycles;
    //uint64_t total_ns;
    srand(34799);

    clock_t pr1, pr2, rk1, rk2, rp1, rp2;
    double prT, rkT, rpT;

    //timing_init();
    //timing_start();

    //Generate Private key using a random generator
    printf("KM Key Generation Process ....\n");
    printf("SK_S:");
    GenKey(SK_S);
    printf("\n");

    //Generate DA public key using the ed25519 base generator 
    //st = timing_counter_get();
    printf("DA Key:KM :");
    performExp(&PK_S, &ed25519_base, SK_S, pks_x, pks_y);
    //et = timing_counter_get();
    //total_cycles = timing_cycles_get(&st, &et);
    //total_ns = timing_cycles_to_ns(total_cycles);

    //printf("\nExp Time = %lld nano seconds\n\n", total_ns);

    pr1 = clock();
    ProcessFunction(RU);
    pr2 = clock();
    prT = ((double)(pr2-pr1)) / CLOCKS_PER_SEC;
    //etA = timing_counter_get();
    //tA_cycles = timing_cycles_get(&stA, &etA);
    //tA_ns = timing_cycles_to_ns(tA_cycles);
    //printf("\nProcess Time for %d users = %lld nano seconds\n\n", cnt, tA_ns);

    printf("reKey Function ========================================================================= \n\n");
    rk1 = clock();
    reKey(RU, SK_S);
    rk2 = clock();
    rkT = ((double)(rk2-rk1)) / CLOCKS_PER_SEC;
    printf("reProcess Function ========================================================================= \n\n");
    rp1 = clock();
    reProcess(RU);
    rp2 = clock();
    rpT = ((double)(rp2-rp1)) / CLOCKS_PER_SEC;

    printf("Total execution time for Processing %d users = %f seconds\n", cnt, prT);
    printf("Total execution time for reKeying %d users = %f seconds\n", cnt, rkT);
    printf("Total execution time for reProcessing %d users = %f seconds\n", cnt, rpT);
    /*
    for (int j = 0; j < cnt; j++){
        printf("User %s variables: \n", RU[j].ID);
        displayHex(RU[j].k_i);
        printf("\n");
        displayHex(RU[j].c_i);
        printf("\n");
        displayHex(RU[j].s_i); 
    }
    */
    
    


    //KM ReKey Process
    /*
    printf("ReKey for A:KM:");
    performExp(&RKA_S, &TK_A, SK_S, rka_x, rka_y);              // rk_i_s = (h^(1/k_i))^k
    printf("\n");
    */

    printf("Process Completed\n");
    //timing_stop();
}
